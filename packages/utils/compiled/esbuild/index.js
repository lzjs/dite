(function(){"use strict";var e={364:function(e,t,r){var l=Object.create;var n=Object.defineProperty;var a=Object.getOwnPropertyDescriptor;var i=Object.getOwnPropertyNames;var s=Object.getPrototypeOf;var o=Object.prototype.hasOwnProperty;var __export=(e,t)=>{for(var r in t)n(e,r,{get:t[r],enumerable:true})};var __copyProps=(e,t,r,l)=>{if(t&&typeof t==="object"||typeof t==="function"){for(let s of i(t))if(!o.call(e,s)&&s!==r)n(e,s,{get:()=>t[s],enumerable:!(l=a(t,s))||l.enumerable})}return e};var __toESM=(e,t,r)=>(r=e!=null?l(s(e)):{},__copyProps(t||!e||!e.__esModule?n(r,"default",{value:e,enumerable:true}):r,e));var __toCommonJS=e=>__copyProps(n({},"__esModule",{value:true}),e);var u={};__export(u,{analyzeMetafile:()=>analyzeMetafile,analyzeMetafileSync:()=>analyzeMetafileSync,build:()=>build,buildSync:()=>buildSync,default:()=>_,formatMessages:()=>formatMessages,formatMessagesSync:()=>formatMessagesSync,initialize:()=>initialize,serve:()=>serve,transform:()=>transform,transformSync:()=>transformSync,version:()=>L});e.exports=__toCommonJS(u);function encodePacket(e){let visit=e=>{if(e===null){t.write8(0)}else if(typeof e==="boolean"){t.write8(1);t.write8(+e)}else if(typeof e==="number"){t.write8(2);t.write32(e|0)}else if(typeof e==="string"){t.write8(3);t.write(c(e))}else if(e instanceof Uint8Array){t.write8(4);t.write(e)}else if(e instanceof Array){t.write8(5);t.write32(e.length);for(let t of e){visit(t)}}else{let r=Object.keys(e);t.write8(6);t.write32(r.length);for(let l of r){t.write(c(l));visit(e[l])}}};let t=new f;t.write32(0);t.write32(e.id<<1|+!e.isRequest);visit(e.value);writeUInt32LE(t.buf,t.len-4,0);return t.buf.subarray(0,t.len)}function decodePacket(e){let visit=()=>{switch(t.read8()){case 0:return null;case 1:return!!t.read8();case 2:return t.read32();case 3:return g(t.read());case 4:return t.read();case 5:{let e=t.read32();let r=[];for(let t=0;t<e;t++){r.push(visit())}return r}case 6:{let e=t.read32();let r={};for(let l=0;l<e;l++){r[g(t.read())]=visit()}return r}default:throw new Error("Invalid packet")}};let t=new f(e);let r=t.read32();let l=(r&1)===0;r>>>=1;let n=visit();if(t.ptr!==e.length){throw new Error("Invalid packet")}return{id:r,isRequest:l,value:n}}var f=class{constructor(e=new Uint8Array(1024)){this.buf=e;this.len=0;this.ptr=0}_write(e){if(this.len+e>this.buf.length){let t=new Uint8Array((this.len+e)*2);t.set(this.buf);this.buf=t}this.len+=e;return this.len-e}write8(e){let t=this._write(1);this.buf[t]=e}write32(e){let t=this._write(4);writeUInt32LE(this.buf,e,t)}write(e){let t=this._write(4+e.length);writeUInt32LE(this.buf,e.length,t);this.buf.set(e,t+4)}_read(e){if(this.ptr+e>this.buf.length){throw new Error("Invalid packet")}this.ptr+=e;return this.ptr-e}read8(){return this.buf[this._read(1)]}read32(){return readUInt32LE(this.buf,this._read(4))}read(){let e=this.read32();let t=new Uint8Array(e);let r=this._read(t.length);t.set(this.buf.subarray(r,r+e));return t}};var c;var g;if(typeof TextEncoder!=="undefined"&&typeof TextDecoder!=="undefined"){let e=new TextEncoder;let t=new TextDecoder;c=t=>e.encode(t);g=e=>t.decode(e)}else if(typeof Buffer!=="undefined"){c=e=>{let t=Buffer.from(e);if(!(t instanceof Uint8Array)){t=new Uint8Array(t)}return t};g=e=>{let{buffer:t,byteOffset:r,byteLength:l}=e;return Buffer.from(t,r,l).toString()}}else{throw new Error("No UTF-8 codec found")}function readUInt32LE(e,t){return e[t++]|e[t++]<<8|e[t++]<<16|e[t++]<<24}function writeUInt32LE(e,t,r){e[r++]=t;e[r++]=t>>8;e[r++]=t>>16;e[r++]=t>>24}function validateTarget(e){e+="";if(e.indexOf(",")>=0)throw new Error(`Invalid target: ${e}`);return e}var canBeAnything=()=>null;var mustBeBoolean=e=>typeof e==="boolean"?null:"a boolean";var mustBeBooleanOrObject=e=>typeof e==="boolean"||typeof e==="object"&&!Array.isArray(e)?null:"a boolean or an object";var mustBeString=e=>typeof e==="string"?null:"a string";var mustBeRegExp=e=>e instanceof RegExp?null:"a RegExp object";var mustBeInteger=e=>typeof e==="number"&&e===(e|0)?null:"an integer";var mustBeFunction=e=>typeof e==="function"?null:"a function";var mustBeArray=e=>Array.isArray(e)?null:"an array";var mustBeObject=e=>typeof e==="object"&&e!==null&&!Array.isArray(e)?null:"an object";var mustBeWebAssemblyModule=e=>e instanceof WebAssembly.Module?null:"a WebAssembly.Module";var mustBeArrayOrRecord=e=>typeof e==="object"&&e!==null?null:"an array or an object";var mustBeObjectOrNull=e=>typeof e==="object"&&!Array.isArray(e)?null:"an object or null";var mustBeStringOrBoolean=e=>typeof e==="string"||typeof e==="boolean"?null:"a string or a boolean";var mustBeStringOrObject=e=>typeof e==="string"||typeof e==="object"&&e!==null&&!Array.isArray(e)?null:"a string or an object";var mustBeStringOrArray=e=>typeof e==="string"||Array.isArray(e)?null:"a string or an array";var mustBeStringOrUint8Array=e=>typeof e==="string"||e instanceof Uint8Array?null:"a string or a Uint8Array";function getFlag(e,t,r,l){let n=e[r];t[r+""]=true;if(n===void 0)return void 0;let a=l(n);if(a!==null)throw new Error(`"${r}" must be ${a}`);return n}function checkForInvalidFlags(e,t,r){for(let l in e){if(!(l in t)){throw new Error(`Invalid option ${r}: "${l}"`)}}}function validateInitializeOptions(e){let t=Object.create(null);let r=getFlag(e,t,"wasmURL",mustBeString);let l=getFlag(e,t,"wasmModule",mustBeWebAssemblyModule);let n=getFlag(e,t,"worker",mustBeBoolean);checkForInvalidFlags(e,t,"in initialize() call");return{wasmURL:r,wasmModule:l,worker:n}}function validateMangleCache(e){let t;if(e!==void 0){t=Object.create(null);for(let r of Object.keys(e)){let l=e[r];if(typeof l==="string"||l===false){t[r]=l}else{throw new Error(`Expected ${JSON.stringify(r)} in mangle cache to map to either a string or false`)}}}return t}function pushLogFlags(e,t,r,l,n){let a=getFlag(t,r,"color",mustBeBoolean);let i=getFlag(t,r,"logLevel",mustBeString);let s=getFlag(t,r,"logLimit",mustBeInteger);if(a!==void 0)e.push(`--color=${a}`);else if(l)e.push(`--color=true`);e.push(`--log-level=${i||n}`);e.push(`--log-limit=${s||0}`)}function pushCommonFlags(e,t,r){let l=getFlag(t,r,"legalComments",mustBeString);let n=getFlag(t,r,"sourceRoot",mustBeString);let a=getFlag(t,r,"sourcesContent",mustBeBoolean);let i=getFlag(t,r,"target",mustBeStringOrArray);let s=getFlag(t,r,"format",mustBeString);let o=getFlag(t,r,"globalName",mustBeString);let u=getFlag(t,r,"mangleProps",mustBeRegExp);let f=getFlag(t,r,"reserveProps",mustBeRegExp);let c=getFlag(t,r,"mangleQuoted",mustBeBoolean);let g=getFlag(t,r,"minify",mustBeBoolean);let d=getFlag(t,r,"minifySyntax",mustBeBoolean);let p=getFlag(t,r,"minifyWhitespace",mustBeBoolean);let h=getFlag(t,r,"minifyIdentifiers",mustBeBoolean);let m=getFlag(t,r,"drop",mustBeArray);let w=getFlag(t,r,"charset",mustBeString);let b=getFlag(t,r,"treeShaking",mustBeBoolean);let y=getFlag(t,r,"ignoreAnnotations",mustBeBoolean);let v=getFlag(t,r,"jsx",mustBeString);let F=getFlag(t,r,"jsxFactory",mustBeString);let k=getFlag(t,r,"jsxFragment",mustBeString);let E=getFlag(t,r,"define",mustBeObject);let x=getFlag(t,r,"logOverride",mustBeObject);let $=getFlag(t,r,"supported",mustBeObject);let S=getFlag(t,r,"pure",mustBeArray);let M=getFlag(t,r,"keepNames",mustBeBoolean);if(l)e.push(`--legal-comments=${l}`);if(n!==void 0)e.push(`--source-root=${n}`);if(a!==void 0)e.push(`--sources-content=${a}`);if(i){if(Array.isArray(i))e.push(`--target=${Array.from(i).map(validateTarget).join(",")}`);else e.push(`--target=${validateTarget(i)}`)}if(s)e.push(`--format=${s}`);if(o)e.push(`--global-name=${o}`);if(g)e.push("--minify");if(d)e.push("--minify-syntax");if(p)e.push("--minify-whitespace");if(h)e.push("--minify-identifiers");if(w)e.push(`--charset=${w}`);if(b!==void 0)e.push(`--tree-shaking=${b}`);if(y)e.push(`--ignore-annotations`);if(m)for(let t of m)e.push(`--drop:${t}`);if(u)e.push(`--mangle-props=${u.source}`);if(f)e.push(`--reserve-props=${f.source}`);if(c!==void 0)e.push(`--mangle-quoted=${c}`);if(v)e.push(`--jsx=${v}`);if(F)e.push(`--jsx-factory=${F}`);if(k)e.push(`--jsx-fragment=${k}`);if(E){for(let t in E){if(t.indexOf("=")>=0)throw new Error(`Invalid define: ${t}`);e.push(`--define:${t}=${E[t]}`)}}if(x){for(let t in x){if(t.indexOf("=")>=0)throw new Error(`Invalid log override: ${t}`);e.push(`--log-override:${t}=${x[t]}`)}}if($){for(let t in $){if(t.indexOf("=")>=0)throw new Error(`Invalid supported: ${t}`);e.push(`--supported:${t}=${$[t]}`)}}if(S)for(let t of S)e.push(`--pure:${t}`);if(M)e.push(`--keep-names`)}function flagsForBuildOptions(e,t,r,l,n){var a;let i=[];let s=[];let o=Object.create(null);let u=null;let f=null;let c=null;pushLogFlags(i,t,o,r,l);pushCommonFlags(i,t,o);let g=getFlag(t,o,"sourcemap",mustBeStringOrBoolean);let d=getFlag(t,o,"bundle",mustBeBoolean);let p=getFlag(t,o,"watch",mustBeBooleanOrObject);let h=getFlag(t,o,"splitting",mustBeBoolean);let m=getFlag(t,o,"preserveSymlinks",mustBeBoolean);let w=getFlag(t,o,"metafile",mustBeBoolean);let b=getFlag(t,o,"outfile",mustBeString);let y=getFlag(t,o,"outdir",mustBeString);let v=getFlag(t,o,"outbase",mustBeString);let F=getFlag(t,o,"platform",mustBeString);let k=getFlag(t,o,"tsconfig",mustBeString);let E=getFlag(t,o,"resolveExtensions",mustBeArray);let x=getFlag(t,o,"nodePaths",mustBeArray);let $=getFlag(t,o,"mainFields",mustBeArray);let S=getFlag(t,o,"conditions",mustBeArray);let M=getFlag(t,o,"external",mustBeArray);let O=getFlag(t,o,"loader",mustBeObject);let I=getFlag(t,o,"outExtension",mustBeObject);let A=getFlag(t,o,"publicPath",mustBeString);let L=getFlag(t,o,"entryNames",mustBeString);let j=getFlag(t,o,"chunkNames",mustBeString);let P=getFlag(t,o,"assetNames",mustBeString);let D=getFlag(t,o,"inject",mustBeArray);let T=getFlag(t,o,"banner",mustBeObject);let _=getFlag(t,o,"footer",mustBeObject);let C=getFlag(t,o,"entryPoints",mustBeArrayOrRecord);let N=getFlag(t,o,"absWorkingDir",mustBeString);let R=getFlag(t,o,"stdin",mustBeObject);let W=(a=getFlag(t,o,"write",mustBeBoolean))!=null?a:n;let z=getFlag(t,o,"allowOverwrite",mustBeBoolean);let q=getFlag(t,o,"incremental",mustBeBoolean)===true;let U=getFlag(t,o,"mangleCache",mustBeObject);o.plugins=true;checkForInvalidFlags(t,o,`in ${e}() call`);if(g)i.push(`--sourcemap${g===true?"":`=${g}`}`);if(d)i.push("--bundle");if(z)i.push("--allow-overwrite");if(p){i.push("--watch");if(typeof p==="boolean"){c={}}else{let t=Object.create(null);let r=getFlag(p,t,"onRebuild",mustBeFunction);checkForInvalidFlags(p,t,`on "watch" in ${e}() call`);c={onRebuild:r}}}if(h)i.push("--splitting");if(m)i.push("--preserve-symlinks");if(w)i.push(`--metafile`);if(b)i.push(`--outfile=${b}`);if(y)i.push(`--outdir=${y}`);if(v)i.push(`--outbase=${v}`);if(F)i.push(`--platform=${F}`);if(k)i.push(`--tsconfig=${k}`);if(E){let e=[];for(let t of E){t+="";if(t.indexOf(",")>=0)throw new Error(`Invalid resolve extension: ${t}`);e.push(t)}i.push(`--resolve-extensions=${e.join(",")}`)}if(A)i.push(`--public-path=${A}`);if(L)i.push(`--entry-names=${L}`);if(j)i.push(`--chunk-names=${j}`);if(P)i.push(`--asset-names=${P}`);if($){let e=[];for(let t of $){t+="";if(t.indexOf(",")>=0)throw new Error(`Invalid main field: ${t}`);e.push(t)}i.push(`--main-fields=${e.join(",")}`)}if(S){let e=[];for(let t of S){t+="";if(t.indexOf(",")>=0)throw new Error(`Invalid condition: ${t}`);e.push(t)}i.push(`--conditions=${e.join(",")}`)}if(M)for(let e of M)i.push(`--external:${e}`);if(T){for(let e in T){if(e.indexOf("=")>=0)throw new Error(`Invalid banner file type: ${e}`);i.push(`--banner:${e}=${T[e]}`)}}if(_){for(let e in _){if(e.indexOf("=")>=0)throw new Error(`Invalid footer file type: ${e}`);i.push(`--footer:${e}=${_[e]}`)}}if(D)for(let e of D)i.push(`--inject:${e}`);if(O){for(let e in O){if(e.indexOf("=")>=0)throw new Error(`Invalid loader extension: ${e}`);i.push(`--loader:${e}=${O[e]}`)}}if(I){for(let e in I){if(e.indexOf("=")>=0)throw new Error(`Invalid out extension: ${e}`);i.push(`--out-extension:${e}=${I[e]}`)}}if(C){if(Array.isArray(C)){for(let e of C){s.push(["",e+""])}}else{for(let[e,t]of Object.entries(C)){s.push([e+"",t+""])}}}if(R){let e=Object.create(null);let t=getFlag(R,e,"contents",mustBeString);let r=getFlag(R,e,"resolveDir",mustBeString);let l=getFlag(R,e,"sourcefile",mustBeString);let n=getFlag(R,e,"loader",mustBeString);checkForInvalidFlags(R,e,'in "stdin" object');if(l)i.push(`--sourcefile=${l}`);if(n)i.push(`--loader=${n}`);if(r)f=r+"";u=t?t+"":""}let B=[];if(x){for(let e of x){e+="";B.push(e)}}return{entries:s,flags:i,write:W,stdinContents:u,stdinResolveDir:f,absWorkingDir:N,incremental:q,nodePaths:B,watch:c,mangleCache:validateMangleCache(U)}}function flagsForTransformOptions(e,t,r,l){let n=[];let a=Object.create(null);pushLogFlags(n,t,a,r,l);pushCommonFlags(n,t,a);let i=getFlag(t,a,"sourcemap",mustBeStringOrBoolean);let s=getFlag(t,a,"tsconfigRaw",mustBeStringOrObject);let o=getFlag(t,a,"sourcefile",mustBeString);let u=getFlag(t,a,"loader",mustBeString);let f=getFlag(t,a,"banner",mustBeString);let c=getFlag(t,a,"footer",mustBeString);let g=getFlag(t,a,"mangleCache",mustBeObject);checkForInvalidFlags(t,a,`in ${e}() call`);if(i)n.push(`--sourcemap=${i===true?"external":i}`);if(s)n.push(`--tsconfig-raw=${typeof s==="string"?s:JSON.stringify(s)}`);if(o)n.push(`--sourcefile=${o}`);if(u)n.push(`--loader=${u}`);if(f)n.push(`--banner=${f}`);if(c)n.push(`--footer=${c}`);return{flags:n,mangleCache:validateMangleCache(g)}}function createChannel(e){let t=new Map;let r=new Map;let l=new Map;let n=new Map;let a=null;let i=0;let s=0;let o=new Uint8Array(16*1024);let u=0;let readFromStdout=e=>{let t=u+e.length;if(t>o.length){let e=new Uint8Array(t*2);e.set(o);o=e}o.set(e,u);u+=e.length;let r=0;while(r+4<=u){let e=readUInt32LE(o,r);if(r+4+e>u){break}r+=4;handleIncomingPacket(o.subarray(r,r+e));r+=e}if(r>0){o.copyWithin(0,r,u);u-=r}};let afterClose=e=>{a={reason:e?": "+(e.message||e):""};const r="The service was stopped"+a.reason;for(let e of t.values()){e(r,null)}t.clear();for(let e of n.values()){e.onWait(r)}n.clear();for(let e of l.values()){try{e(new Error(r),null)}catch(e){console.error(e)}}l.clear()};let sendRequest=(r,l,n)=>{if(a)return n("The service is no longer running"+a.reason,null);let s=i++;t.set(s,((e,t)=>{try{n(e,t)}finally{if(r)r.unref()}}));if(r)r.ref();e.writeToStdin(encodePacket({id:s,isRequest:true,value:l}))};let sendResponse=(t,r)=>{if(a)throw new Error("The service is no longer running"+a.reason);e.writeToStdin(encodePacket({id:t,isRequest:false,value:r}))};let handleRequest=async(t,a)=>{try{switch(a.command){case"ping":{sendResponse(t,{});break}case"on-start":{let e=r.get(a.key);if(!e)sendResponse(t,{});else sendResponse(t,await e(a));break}case"on-resolve":{let e=r.get(a.key);if(!e)sendResponse(t,{});else sendResponse(t,await e(a));break}case"on-load":{let e=r.get(a.key);if(!e)sendResponse(t,{});else sendResponse(t,await e(a));break}case"serve-request":{let e=n.get(a.key);if(e&&e.onRequest)e.onRequest(a.args);sendResponse(t,{});break}case"serve-wait":{let e=n.get(a.key);if(e)e.onWait(a.error);sendResponse(t,{});break}case"watch-rebuild":{let e=l.get(a.key);try{if(e)e(null,a.args)}catch(e){console.error(e)}sendResponse(t,{});break}default:throw new Error(`Invalid command: `+a.command)}}catch(r){sendResponse(t,{errors:[extractErrorMessageV8(r,e,null,void 0,"")]})}};let f=true;let handleIncomingPacket=e=>{if(f){f=false;let t=String.fromCharCode(...e);if(t!=="0.14.49"){throw new Error(`Cannot start service: Host version "${"0.14.49"}" does not match binary version ${JSON.stringify(t)}`)}return}let r=decodePacket(e);if(r.isRequest){handleRequest(r.id,r.value)}else{let e=t.get(r.id);t.delete(r.id);if(r.value.error)e(r.value.error,{});else e(null,r.value)}};let handlePlugins=async(t,l,n,a,i)=>{let s=[];let o=[];let u={};let f={};let g=0;let d=0;let p=[];let h=false;l=[...l];for(let r of l){let l={};if(typeof r!=="object")throw new Error(`Plugin at index ${d} must be an object`);const c=getFlag(r,l,"name",mustBeString);if(typeof c!=="string"||c==="")throw new Error(`Plugin at index ${d} is missing a name`);try{let m=getFlag(r,l,"setup",mustBeFunction);if(typeof m!=="function")throw new Error(`Plugin is missing a setup function`);checkForInvalidFlags(r,l,`on plugin ${JSON.stringify(c)}`);let w={name:c,onResolve:[],onLoad:[]};d++;let resolve=(e,t={})=>{if(!h)throw new Error('Cannot call "resolve" before plugin setup has completed');if(typeof e!=="string")throw new Error(`The path to resolve must be a string`);let r=Object.create(null);let l=getFlag(t,r,"pluginName",mustBeString);let s=getFlag(t,r,"importer",mustBeString);let o=getFlag(t,r,"namespace",mustBeString);let u=getFlag(t,r,"resolveDir",mustBeString);let f=getFlag(t,r,"kind",mustBeString);let g=getFlag(t,r,"pluginData",canBeAnything);checkForInvalidFlags(t,r,"in resolve() call");return new Promise(((t,r)=>{const d={command:"resolve",path:e,key:n,pluginName:c};if(l!=null)d.pluginName=l;if(s!=null)d.importer=s;if(o!=null)d.namespace=o;if(u!=null)d.resolveDir=u;if(f!=null)d.kind=f;if(g!=null)d.pluginData=a.store(g);sendRequest(i,d,((e,l)=>{if(e!==null)r(new Error(e));else t({errors:replaceDetailsInMessages(l.errors,a),warnings:replaceDetailsInMessages(l.warnings,a),path:l.path,external:l.external,sideEffects:l.sideEffects,namespace:l.namespace,suffix:l.suffix,pluginData:a.load(l.pluginData)})}))}))};let b=m({initialOptions:t,resolve:resolve,onStart(t){let r=`This error came from the "onStart" callback registered here:`;let l=extractCallerV8(new Error(r),e,"onStart");s.push({name:c,callback:t,note:l})},onEnd(t){let r=`This error came from the "onEnd" callback registered here:`;let l=extractCallerV8(new Error(r),e,"onEnd");o.push({name:c,callback:t,note:l})},onResolve(t,r){let l=`This error came from the "onResolve" callback registered here:`;let n=extractCallerV8(new Error(l),e,"onResolve");let a={};let i=getFlag(t,a,"filter",mustBeRegExp);let s=getFlag(t,a,"namespace",mustBeString);checkForInvalidFlags(t,a,`in onResolve() call for plugin ${JSON.stringify(c)}`);if(i==null)throw new Error(`onResolve() call is missing a filter`);let o=g++;u[o]={name:c,callback:r,note:n};w.onResolve.push({id:o,filter:i.source,namespace:s||""})},onLoad(t,r){let l=`This error came from the "onLoad" callback registered here:`;let n=extractCallerV8(new Error(l),e,"onLoad");let a={};let i=getFlag(t,a,"filter",mustBeRegExp);let s=getFlag(t,a,"namespace",mustBeString);checkForInvalidFlags(t,a,`in onLoad() call for plugin ${JSON.stringify(c)}`);if(i==null)throw new Error(`onLoad() call is missing a filter`);let o=g++;f[o]={name:c,callback:r,note:n};w.onLoad.push({id:o,filter:i.source,namespace:s||""})},esbuild:e.esbuild});if(b)await b;p.push(w)}catch(e){return{ok:false,error:e,pluginName:c}}}const callback=async t=>{switch(t.command){case"on-start":{let t={errors:[],warnings:[]};await Promise.all(s.map((async({name:r,callback:l,note:n})=>{try{let e=await l();if(e!=null){if(typeof e!=="object")throw new Error(`Expected onStart() callback in plugin ${JSON.stringify(r)} to return an object`);let l={};let n=getFlag(e,l,"errors",mustBeArray);let i=getFlag(e,l,"warnings",mustBeArray);checkForInvalidFlags(e,l,`from onStart() callback in plugin ${JSON.stringify(r)}`);if(n!=null)t.errors.push(...sanitizeMessages(n,"errors",a,r));if(i!=null)t.warnings.push(...sanitizeMessages(i,"warnings",a,r))}}catch(l){t.errors.push(extractErrorMessageV8(l,e,a,n&&n(),r))}})));return t}case"on-resolve":{let r={},l="",n,i;for(let s of t.ids){try{({name:l,callback:n,note:i}=u[s]);let e=await n({path:t.path,importer:t.importer,namespace:t.namespace,resolveDir:t.resolveDir,kind:t.kind,pluginData:a.load(t.pluginData)});if(e!=null){if(typeof e!=="object")throw new Error(`Expected onResolve() callback in plugin ${JSON.stringify(l)} to return an object`);let t={};let n=getFlag(e,t,"pluginName",mustBeString);let i=getFlag(e,t,"path",mustBeString);let o=getFlag(e,t,"namespace",mustBeString);let u=getFlag(e,t,"suffix",mustBeString);let f=getFlag(e,t,"external",mustBeBoolean);let c=getFlag(e,t,"sideEffects",mustBeBoolean);let g=getFlag(e,t,"pluginData",canBeAnything);let d=getFlag(e,t,"errors",mustBeArray);let p=getFlag(e,t,"warnings",mustBeArray);let h=getFlag(e,t,"watchFiles",mustBeArray);let m=getFlag(e,t,"watchDirs",mustBeArray);checkForInvalidFlags(e,t,`from onResolve() callback in plugin ${JSON.stringify(l)}`);r.id=s;if(n!=null)r.pluginName=n;if(i!=null)r.path=i;if(o!=null)r.namespace=o;if(u!=null)r.suffix=u;if(f!=null)r.external=f;if(c!=null)r.sideEffects=c;if(g!=null)r.pluginData=a.store(g);if(d!=null)r.errors=sanitizeMessages(d,"errors",a,l);if(p!=null)r.warnings=sanitizeMessages(p,"warnings",a,l);if(h!=null)r.watchFiles=sanitizeStringArray(h,"watchFiles");if(m!=null)r.watchDirs=sanitizeStringArray(m,"watchDirs");break}}catch(t){return{id:s,errors:[extractErrorMessageV8(t,e,a,i&&i(),l)]}}}return r}case"on-load":{let r={},l="",n,i;for(let s of t.ids){try{({name:l,callback:n,note:i}=f[s]);let e=await n({path:t.path,namespace:t.namespace,suffix:t.suffix,pluginData:a.load(t.pluginData)});if(e!=null){if(typeof e!=="object")throw new Error(`Expected onLoad() callback in plugin ${JSON.stringify(l)} to return an object`);let t={};let n=getFlag(e,t,"pluginName",mustBeString);let i=getFlag(e,t,"contents",mustBeStringOrUint8Array);let o=getFlag(e,t,"resolveDir",mustBeString);let u=getFlag(e,t,"pluginData",canBeAnything);let f=getFlag(e,t,"loader",mustBeString);let g=getFlag(e,t,"errors",mustBeArray);let d=getFlag(e,t,"warnings",mustBeArray);let p=getFlag(e,t,"watchFiles",mustBeArray);let h=getFlag(e,t,"watchDirs",mustBeArray);checkForInvalidFlags(e,t,`from onLoad() callback in plugin ${JSON.stringify(l)}`);r.id=s;if(n!=null)r.pluginName=n;if(i instanceof Uint8Array)r.contents=i;else if(i!=null)r.contents=c(i);if(o!=null)r.resolveDir=o;if(u!=null)r.pluginData=a.store(u);if(f!=null)r.loader=f;if(g!=null)r.errors=sanitizeMessages(g,"errors",a,l);if(d!=null)r.warnings=sanitizeMessages(d,"warnings",a,l);if(p!=null)r.watchFiles=sanitizeStringArray(p,"watchFiles");if(h!=null)r.watchDirs=sanitizeStringArray(h,"watchDirs");break}}catch(t){return{id:s,errors:[extractErrorMessageV8(t,e,a,i&&i(),l)]}}}return r}default:throw new Error(`Invalid command: `+t.command)}};let runOnEndCallbacks=(e,t,r)=>r();if(o.length>0){runOnEndCallbacks=(e,t,r)=>{(async()=>{for(const{name:r,callback:l,note:n}of o){try{await l(e)}catch(l){e.errors.push(await new Promise((e=>t(l,r,n&&n(),e))))}}})().then(r)}}h=true;let m=0;return{ok:true,requestPlugins:p,runOnEndCallbacks:runOnEndCallbacks,pluginRefs:{ref(){if(++m===1)r.set(n,callback)},unref(){if(--m===0)r.delete(n)}}}};let buildServeData=(e,t,r,l)=>{let a={};let i=getFlag(t,a,"port",mustBeInteger);let s=getFlag(t,a,"host",mustBeString);let o=getFlag(t,a,"servedir",mustBeString);let u=getFlag(t,a,"onRequest",mustBeFunction);let f;let c=new Promise(((e,t)=>{f=r=>{n.delete(l);if(r!==null)t(new Error(r));else e()}}));r.serve={};checkForInvalidFlags(t,a,`in serve() call`);if(i!==void 0)r.serve.port=i;if(s!==void 0)r.serve.host=s;if(o!==void 0)r.serve.servedir=o;n.set(l,{onRequest:u,onWait:f});return{wait:c,stop(){sendRequest(e,{command:"serve-stop",key:l},(()=>{}))}}};const d="warning";const p="silent";let buildOrServe=t=>{let r=s++;const l=createObjectStash();let n;let{refs:a,options:i,isTTY:o,callback:u}=t;if(typeof i==="object"){let e=i.plugins;if(e!==void 0){if(!Array.isArray(e))throw new Error(`"plugins" must be an array`);n=e}}let logPluginError=(t,r,n,s)=>{let u=[];try{pushLogFlags(u,i,{},o,d)}catch{}const f=extractErrorMessageV8(t,e,l,n,r);sendRequest(a,{command:"error",flags:u,error:f},(()=>{f.detail=l.load(f.detail);s(f)}))};let handleError=(e,t)=>{logPluginError(e,t,void 0,(e=>{u(failureErrorWithLog("Build failed",[e],[]),null)}))};if(n&&n.length>0){if(e.isSync)return handleError(new Error("Cannot use plugins in synchronous API calls"),"");handlePlugins(i,n,r,l,a).then((e=>{if(!e.ok){handleError(e.error,e.pluginName)}else{try{buildOrServeContinue({...t,key:r,details:l,logPluginError:logPluginError,requestPlugins:e.requestPlugins,runOnEndCallbacks:e.runOnEndCallbacks,pluginRefs:e.pluginRefs})}catch(e){handleError(e,"")}}}),(e=>handleError(e,"")))}else{try{buildOrServeContinue({...t,key:r,details:l,logPluginError:logPluginError,requestPlugins:null,runOnEndCallbacks:(e,t,r)=>r(),pluginRefs:null})}catch(e){handleError(e,"")}}};let buildOrServeContinue=({callName:t,refs:r,serveOptions:n,options:i,isTTY:s,defaultWD:o,callback:u,key:f,details:c,logPluginError:p,requestPlugins:h,runOnEndCallbacks:m,pluginRefs:w})=>{const b={ref(){if(w)w.ref();if(r)r.ref()},unref(){if(w)w.unref();if(r)r.unref()}};let y=!e.isWriteUnavailable;let{entries:v,flags:F,write:k,stdinContents:E,stdinResolveDir:x,absWorkingDir:$,incremental:S,nodePaths:M,watch:O,mangleCache:I}=flagsForBuildOptions(t,i,s,d,y);let A={command:"build",key:f,entries:v,flags:F,write:k,stdinContents:E,stdinResolveDir:x,absWorkingDir:$||o,incremental:S,nodePaths:M};if(h)A.plugins=h;if(I)A.mangleCache=I;let L=n&&buildServeData(b,n,A,f);let j;let P;let copyResponseToResult=(e,t)=>{if(e.outputFiles)t.outputFiles=e.outputFiles.map(convertOutputFiles);if(e.metafile)t.metafile=JSON.parse(e.metafile);if(e.mangleCache)t.mangleCache=e.mangleCache;if(e.writeToStdout!==void 0)console.log(g(e.writeToStdout).replace(/\n$/,""))};let buildResponseToResult=(e,t)=>{let r={errors:replaceDetailsInMessages(e.errors,c),warnings:replaceDetailsInMessages(e.warnings,c)};copyResponseToResult(e,r);m(r,p,(()=>{if(r.errors.length>0){return t(failureErrorWithLog("Build failed",r.errors,r.warnings),null)}if(e.rebuild){if(!j){let e=false;j=()=>new Promise(((r,l)=>{if(e||a)throw new Error("Cannot rebuild");sendRequest(b,{command:"rebuild",key:f},((e,n)=>{if(e){const r={id:"",pluginName:"",text:e,location:null,notes:[],detail:void 0};return t(failureErrorWithLog("Build failed",[r],[]),null)}buildResponseToResult(n,((e,t)=>{if(e)l(e);else r(t)}))}))}));b.ref();j.dispose=()=>{if(e)return;e=true;sendRequest(b,{command:"rebuild-dispose",key:f},(()=>{}));b.unref()}}r.rebuild=j}if(e.watch){if(!P){let e=false;b.ref();P=()=>{if(e)return;e=true;l.delete(f);sendRequest(b,{command:"watch-stop",key:f},(()=>{}));b.unref()};if(O){l.set(f,((e,t)=>{if(e){if(O.onRebuild)O.onRebuild(e,null);return}let r={errors:replaceDetailsInMessages(t.errors,c),warnings:replaceDetailsInMessages(t.warnings,c)};copyResponseToResult(t,r);m(r,p,(()=>{if(r.errors.length>0){if(O.onRebuild)O.onRebuild(failureErrorWithLog("Build failed",r.errors,r.warnings),null);return}if(t.rebuildID!==void 0)r.rebuild=j;r.stop=P;if(O.onRebuild)O.onRebuild(null,r)}))}))}}r.stop=P}t(null,r)}))};if(k&&e.isWriteUnavailable)throw new Error(`The "write" option is unavailable in this environment`);if(S&&e.isSync)throw new Error(`Cannot use "incremental" with a synchronous build`);if(O&&e.isSync)throw new Error(`Cannot use "watch" with a synchronous build`);sendRequest(b,A,((e,t)=>{if(e)return u(new Error(e),null);if(L){let e=t;let r=false;b.ref();let l={port:e.port,host:e.host,wait:L.wait,stop(){if(r)return;r=true;L.stop();b.unref()}};b.ref();L.wait.then(b.unref,b.unref);return u(null,l)}return buildResponseToResult(t,u)}))};let transform2=({callName:t,refs:r,input:l,options:n,isTTY:a,fs:i,callback:s})=>{const o=createObjectStash();let start=u=>{try{if(typeof l!=="string")throw new Error('The input to "transform" must be a string');let{flags:e,mangleCache:f}=flagsForTransformOptions(t,n,a,p);let c={command:"transform",flags:e,inputFS:u!==null,input:u!==null?u:l};if(f)c.mangleCache=f;sendRequest(r,c,((e,t)=>{if(e)return s(new Error(e),null);let r=replaceDetailsInMessages(t.errors,o);let l=replaceDetailsInMessages(t.warnings,o);let n=1;let next=()=>{if(--n===0){let e={warnings:l,code:t.code,map:t.map};if(t.mangleCache)e.mangleCache=t==null?void 0:t.mangleCache;s(null,e)}};if(r.length>0)return s(failureErrorWithLog("Transform failed",r,l),null);if(t.codeFS){n++;i.readFile(t.code,((e,r)=>{if(e!==null){s(e,null)}else{t.code=r;next()}}))}if(t.mapFS){n++;i.readFile(t.map,((e,r)=>{if(e!==null){s(e,null)}else{t.map=r;next()}}))}next()}))}catch(t){let l=[];try{pushLogFlags(l,n,{},a,p)}catch{}const i=extractErrorMessageV8(t,e,o,void 0,"");sendRequest(r,{command:"error",flags:l,error:i},(()=>{i.detail=o.load(i.detail);s(failureErrorWithLog("Transform failed",[i],[]),null)}))}};if(typeof l==="string"&&l.length>1024*1024){let e=start;start=()=>i.writeFile(l,e)}start(null)};let formatMessages2=({callName:e,refs:t,messages:r,options:l,callback:n})=>{let a=sanitizeMessages(r,"messages",null,"");if(!l)throw new Error(`Missing second argument in ${e}() call`);let i={};let s=getFlag(l,i,"kind",mustBeString);let o=getFlag(l,i,"color",mustBeBoolean);let u=getFlag(l,i,"terminalWidth",mustBeInteger);checkForInvalidFlags(l,i,`in ${e}() call`);if(s===void 0)throw new Error(`Missing "kind" in ${e}() call`);if(s!=="error"&&s!=="warning")throw new Error(`Expected "kind" to be "error" or "warning" in ${e}() call`);let f={command:"format-msgs",messages:a,isWarning:s==="warning"};if(o!==void 0)f.color=o;if(u!==void 0)f.terminalWidth=u;sendRequest(t,f,((e,t)=>{if(e)return n(new Error(e),null);n(null,t.messages)}))};let analyzeMetafile2=({callName:e,refs:t,metafile:r,options:l,callback:n})=>{if(l===void 0)l={};let a={};let i=getFlag(l,a,"color",mustBeBoolean);let s=getFlag(l,a,"verbose",mustBeBoolean);checkForInvalidFlags(l,a,`in ${e}() call`);let o={command:"analyze-metafile",metafile:r};if(i!==void 0)o.color=i;if(s!==void 0)o.verbose=s;sendRequest(t,o,((e,t)=>{if(e)return n(new Error(e),null);n(null,t.result)}))};return{readFromStdout:readFromStdout,afterClose:afterClose,service:{buildOrServe:buildOrServe,transform:transform2,formatMessages:formatMessages2,analyzeMetafile:analyzeMetafile2}}}function createObjectStash(){const e=new Map;let t=0;return{load(t){return e.get(t)},store(r){if(r===void 0)return-1;const l=t++;e.set(l,r);return l}}}function extractCallerV8(e,t,r){let l;let n=false;return()=>{if(n)return l;n=true;try{let n=(e.stack+"").split("\n");n.splice(1,1);let a=parseStackLinesV8(t,n,r);if(a){l={text:e.message,location:a};return l}}catch{}}}function extractErrorMessageV8(e,t,r,l,n){let a="Internal error";let i=null;try{a=(e&&e.message||e)+""}catch{}try{i=parseStackLinesV8(t,(e.stack+"").split("\n"),"")}catch{}return{id:"",pluginName:n,text:a,location:i,notes:l?[l]:[],detail:r?r.store(e):-1}}function parseStackLinesV8(e,t,r){let l="    at ";if(e.readFileSync&&!t[0].startsWith(l)&&t[1].startsWith(l)){for(let n=1;n<t.length;n++){let a=t[n];if(!a.startsWith(l))continue;a=a.slice(l.length);while(true){let l=/^(?:new |async )?\S+ \((.*)\)$/.exec(a);if(l){a=l[1];continue}l=/^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(a);if(l){a=l[1];continue}l=/^(\S+):(\d+):(\d+)$/.exec(a);if(l){let n;try{n=e.readFileSync(l[1],"utf8")}catch{break}let a=n.split(/\r\n|\r|\n|\u2028|\u2029/)[+l[2]-1]||"";let i=+l[3]-1;let s=a.slice(i,i+r.length)===r?r.length:0;return{file:l[1],namespace:"file",line:+l[2],column:c(a.slice(0,i)).length,length:c(a.slice(i,i+s)).length,lineText:a+"\n"+t.slice(1).join("\n"),suggestion:""}}break}}}return null}function failureErrorWithLog(e,t,r){let l=5;let n=t.length<1?"":` with ${t.length} error${t.length<2?"":"s"}:`+t.slice(0,l+1).map(((e,t)=>{if(t===l)return"\n...";if(!e.location)return`\nerror: ${e.text}`;let{file:r,line:n,column:a}=e.location;let i=e.pluginName?`[plugin: ${e.pluginName}] `:"";return`\n${r}:${n}:${a}: ERROR: ${i}${e.text}`})).join("");let a=new Error(`${e}${n}`);a.errors=t;a.warnings=r;return a}function replaceDetailsInMessages(e,t){for(const r of e){r.detail=t.load(r.detail)}return e}function sanitizeLocation(e,t){if(e==null)return null;let r={};let l=getFlag(e,r,"file",mustBeString);let n=getFlag(e,r,"namespace",mustBeString);let a=getFlag(e,r,"line",mustBeInteger);let i=getFlag(e,r,"column",mustBeInteger);let s=getFlag(e,r,"length",mustBeInteger);let o=getFlag(e,r,"lineText",mustBeString);let u=getFlag(e,r,"suggestion",mustBeString);checkForInvalidFlags(e,r,t);return{file:l||"",namespace:n||"",line:a||0,column:i||0,length:s||0,lineText:o||"",suggestion:u||""}}function sanitizeMessages(e,t,r,l){let n=[];let a=0;for(const i of e){let e={};let s=getFlag(i,e,"id",mustBeString);let o=getFlag(i,e,"pluginName",mustBeString);let u=getFlag(i,e,"text",mustBeString);let f=getFlag(i,e,"location",mustBeObjectOrNull);let c=getFlag(i,e,"notes",mustBeArray);let g=getFlag(i,e,"detail",canBeAnything);let d=`in element ${a} of "${t}"`;checkForInvalidFlags(i,e,d);let p=[];if(c){for(const e of c){let t={};let r=getFlag(e,t,"text",mustBeString);let l=getFlag(e,t,"location",mustBeObjectOrNull);checkForInvalidFlags(e,t,d);p.push({text:r||"",location:sanitizeLocation(l,d)})}}n.push({id:s||"",pluginName:o||l,text:u||"",location:sanitizeLocation(f,d),notes:p,detail:r?r.store(g):-1});a++}return n}function sanitizeStringArray(e,t){const r=[];for(const l of e){if(typeof l!=="string")throw new Error(`${JSON.stringify(t)} must be an array of strings`);r.push(l)}return r}function convertOutputFiles({path:e,contents:t}){let r=null;return{path:e,contents:t,get text(){if(r===null)r=g(t);return r}}}var d=r(147);var p=r(37);var h=r(17);var m=process.env.ESBUILD_BINARY_PATH||m;var w={"win32 arm64 LE":"esbuild-windows-arm64","win32 ia32 LE":"esbuild-windows-32","win32 x64 LE":"esbuild-windows-64"};var b={"android arm64 LE":"esbuild-android-arm64","darwin arm64 LE":"esbuild-darwin-arm64","darwin x64 LE":"esbuild-darwin-64","freebsd arm64 LE":"esbuild-freebsd-arm64","freebsd x64 LE":"esbuild-freebsd-64","linux arm LE":"esbuild-linux-arm","linux arm64 LE":"esbuild-linux-arm64","linux ia32 LE":"esbuild-linux-32","linux mips64el LE":"esbuild-linux-mips64le","linux ppc64 LE":"esbuild-linux-ppc64le","linux riscv64 LE":"esbuild-linux-riscv64","linux s390x BE":"esbuild-linux-s390x","linux x64 LE":"esbuild-linux-64","netbsd x64 LE":"esbuild-netbsd-64","openbsd x64 LE":"esbuild-openbsd-64","sunos x64 LE":"esbuild-sunos-64"};var y={"android x64 LE":"esbuild-android-64"};function pkgAndSubpathForCurrentPlatform(){let e;let t;let r=false;let l=`${process.platform} ${p.arch()} ${p.endianness()}`;if(l in w){e=w[l];t="esbuild.exe"}else if(l in b){e=b[l];t="bin/esbuild"}else if(l in y){e=y[l];t="bin/esbuild";r=true}else{throw new Error(`Unsupported platform: ${l}`)}return{pkg:e,subpath:t,isWASM:r}}function pkgForSomeOtherPlatform(){const e=471;const t=h.dirname(h.dirname(h.dirname(e)));if(h.basename(t)==="node_modules"){for(const e in b){try{const r=b[e];if(d.existsSync(h.join(t,r)))return r}catch{}}for(const e in w){try{const r=w[e];if(d.existsSync(h.join(t,r)))return r}catch{}}}return null}function downloadedBinPath(e,t){const r=h.dirname(471);return h.join(r,`downloaded-${e}-${h.basename(t)}`)}function generateBinPath(){if(m){return{binPath:m,isWASM:false}}const{pkg:e,subpath:t,isWASM:l}=pkgAndSubpathForCurrentPlatform();let n;try{n=require.resolve(`${e}/${t}`)}catch(r){n=downloadedBinPath(e,t);if(!d.existsSync(n)){try{require.resolve(e)}catch{const t=pkgForSomeOtherPlatform();if(t){throw new Error(`\nYou installed esbuild on another platform than the one you're currently using.\nThis won't work because esbuild is written with native code and needs to\ninstall a platform-specific binary executable.\n\nSpecifically the "${t}" package is present but this platform\nneeds the "${e}" package instead. People often get into this\nsituation by installing esbuild on Windows or macOS and copying "node_modules"\ninto a Docker image that runs Linux, or by copying "node_modules" between\nWindows and WSL environments.\n\nIf you are installing with npm, you can try not copying the "node_modules"\ndirectory when you copy the files over, and running "npm ci" or "npm install"\non the destination platform after the copy. Or you could consider using yarn\ninstead which has built-in support for installing a package on multiple\nplatforms simultaneously.\n\nIf you are installing with yarn, you can try listing both this platform and the\nother platform in your ".yarnrc.yml" file using the "supportedArchitectures"\nfeature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures\nKeep in mind that this means multiple copies of esbuild will be present.\n\nAnother alternative is to use the "esbuild-wasm" package instead, which works\nthe same way on all platforms. But it comes with a heavy performance cost and\ncan sometimes be 10x slower than the "esbuild" package, so you may also not\nwant to do that.\n`)}throw new Error(`The package "${e}" could not be found, and is needed by esbuild.\n\nIf you are installing esbuild with npm, make sure that you don't specify the\n"--no-optional" flag. The "optionalDependencies" package.json feature is used\nby esbuild to install the correct binary executable for your current platform.`)}throw r}}let a=false;try{r(125);a=true}catch(e){}if(a){const r=h.dirname(471);const a=h.join(r,`pnpapi-${e}-${h.basename(t)}`);if(!d.existsSync(a)){d.copyFileSync(n,a);d.chmodSync(a,493)}return{binPath:a,isWASM:l}}return{binPath:n,isWASM:l}}var v=r(81);var F=r(113);var k=r(17);var E=r(147);var x=r(37);var $=r(224);var S;if(process.env.ESBUILD_WORKER_THREADS!=="0"){try{S=r(267)}catch{}let[e,t]=process.versions.node.split(".");if(+e<12||+e===12&&+t<17||+e===13&&+t<13){S=void 0}}var M;var O=((M=S==null?void 0:S.workerData)==null?void 0:M.esbuildVersion)==="0.14.49";var esbuildCommandAndArgs=()=>{if((!m||false)&&(k.basename(__filename)!=="main.js"||k.basename(__dirname)!=="lib")){throw new Error(`The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.\n\nMore information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`)}if(false){}const{binPath:e,isWASM:t}=generateBinPath();if(t){return["node",[e]]}else{return[e,[]]}};var isTTY=()=>$.isatty(2);var I={readFile(e,t){try{let r=E.readFileSync(e,"utf8");try{E.unlinkSync(e)}catch{}t(null,r)}catch(e){t(e,null)}},writeFile(e,t){try{let r=randomFileName();E.writeFileSync(r,e);t(r)}catch{t(null)}}};var A={readFile(e,t){try{E.readFile(e,"utf8",((r,l)=>{try{E.unlink(e,(()=>t(r,l)))}catch{t(r,l)}}))}catch(e){t(e,null)}},writeFile(e,t){try{let r=randomFileName();E.writeFile(r,e,(e=>e!==null?t(null):t(r)))}catch{t(null)}}};var L="0.14.49";var build=e=>ensureServiceIsRunning().build(e);var serve=(e,t)=>ensureServiceIsRunning().serve(e,t);var transform=(e,t)=>ensureServiceIsRunning().transform(e,t);var formatMessages=(e,t)=>ensureServiceIsRunning().formatMessages(e,t);var analyzeMetafile=(e,t)=>ensureServiceIsRunning().analyzeMetafile(e,t);var buildSync=e=>{if(S&&!O){if(!T)T=startWorkerThreadService(S);return T.buildSync(e)}let t;runServiceSync((r=>r.buildOrServe({callName:"buildSync",refs:null,serveOptions:null,options:e,isTTY:isTTY(),defaultWD:P,callback:(e,r)=>{if(e)throw e;t=r}})));return t};var transformSync=(e,t)=>{if(S&&!O){if(!T)T=startWorkerThreadService(S);return T.transformSync(e,t)}let r;runServiceSync((l=>l.transform({callName:"transformSync",refs:null,input:e,options:t||{},isTTY:isTTY(),fs:I,callback:(e,t)=>{if(e)throw e;r=t}})));return r};var formatMessagesSync=(e,t)=>{if(S&&!O){if(!T)T=startWorkerThreadService(S);return T.formatMessagesSync(e,t)}let r;runServiceSync((l=>l.formatMessages({callName:"formatMessagesSync",refs:null,messages:e,options:t,callback:(e,t)=>{if(e)throw e;r=t}})));return r};var analyzeMetafileSync=(e,t)=>{if(S&&!O){if(!T)T=startWorkerThreadService(S);return T.analyzeMetafileSync(e,t)}let r;runServiceSync((l=>l.analyzeMetafile({callName:"analyzeMetafileSync",refs:null,metafile:typeof e==="string"?e:JSON.stringify(e),options:t,callback:(e,t)=>{if(e)throw e;r=t}})));return r};var j=false;var initialize=e=>{e=validateInitializeOptions(e||{});if(e.wasmURL)throw new Error(`The "wasmURL" option only works in the browser`);if(e.wasmModule)throw new Error(`The "wasmModule" option only works in the browser`);if(e.worker)throw new Error(`The "worker" option only works in the browser`);if(j)throw new Error('Cannot call "initialize" more than once');ensureServiceIsRunning();j=true;return Promise.resolve()};var P=process.cwd();var D;var ensureServiceIsRunning=()=>{if(D)return D;let[e,t]=esbuildCommandAndArgs();let r=v.spawn(e,t.concat(`--service=${"0.14.49"}`,"--ping"),{windowsHide:true,stdio:["pipe","pipe","inherit"],cwd:P});let{readFromStdout:l,afterClose:n,service:a}=createChannel({writeToStdin(e){r.stdin.write(e,(e=>{if(e)n(e)}))},readFileSync:E.readFileSync,isSync:false,isWriteUnavailable:false,esbuild:u});r.stdin.on("error",n);r.on("error",n);const i=r.stdin;const s=r.stdout;s.on("data",l);s.on("end",n);let o=0;r.unref();if(i.unref){i.unref()}if(s.unref){s.unref()}const f={ref(){if(++o===1)r.ref()},unref(){if(--o===0)r.unref()}};D={build:e=>new Promise(((t,r)=>{a.buildOrServe({callName:"build",refs:f,serveOptions:null,options:e,isTTY:isTTY(),defaultWD:P,callback:(e,l)=>e?r(e):t(l)})})),serve:(e,t)=>{if(e===null||typeof e!=="object")throw new Error("The first argument must be an object");return new Promise(((r,l)=>a.buildOrServe({callName:"serve",refs:f,serveOptions:e,options:t,isTTY:isTTY(),defaultWD:P,callback:(e,t)=>e?l(e):r(t)})))},transform:(e,t)=>new Promise(((r,l)=>a.transform({callName:"transform",refs:f,input:e,options:t||{},isTTY:isTTY(),fs:A,callback:(e,t)=>e?l(e):r(t)}))),formatMessages:(e,t)=>new Promise(((r,l)=>a.formatMessages({callName:"formatMessages",refs:f,messages:e,options:t,callback:(e,t)=>e?l(e):r(t)}))),analyzeMetafile:(e,t)=>new Promise(((r,l)=>a.analyzeMetafile({callName:"analyzeMetafile",refs:f,metafile:typeof e==="string"?e:JSON.stringify(e),options:t,callback:(e,t)=>e?l(e):r(t)})))};return D};var runServiceSync=e=>{let[t,r]=esbuildCommandAndArgs();let l=new Uint8Array;let{readFromStdout:n,afterClose:a,service:i}=createChannel({writeToStdin(e){if(l.length!==0)throw new Error("Must run at most one command");l=e},isSync:true,isWriteUnavailable:false,esbuild:u});e(i);let s=v.execFileSync(t,r.concat(`--service=${"0.14.49"}`),{cwd:P,windowsHide:true,input:l,maxBuffer:+process.env.ESBUILD_MAX_BUFFER||16*1024*1024});n(s);a(null)};var randomFileName=()=>k.join(x.tmpdir(),`esbuild-${F.randomBytes(32).toString("hex")}`);var T=null;var startWorkerThreadService=e=>{let{port1:t,port2:r}=new e.MessageChannel;let l=new e.Worker(__filename,{workerData:{workerPort:r,defaultWD:P,esbuildVersion:"0.14.49"},transferList:[r],execArgv:[]});let n=0;let a=false;let fakeBuildError=e=>{let t=new Error(`Build failed with 1 error:\nerror: ${e}`);let r=[{id:"",pluginName:"",text:e,location:null,notes:[],detail:void 0}];t.errors=r;t.warnings=[];return t};let validateBuildSyncOptions=e=>{if(!e)return;let t=e.plugins;let r=e.incremental;let l=e.watch;if(t&&t.length>0)throw fakeBuildError(`Cannot use plugins in synchronous API calls`);if(r)throw fakeBuildError(`Cannot use "incremental" with a synchronous build`);if(l)throw fakeBuildError(`Cannot use "watch" with a synchronous build`)};let applyProperties=(e,t)=>{for(let r in t){e[r]=t[r]}};let runCallSync=(r,i)=>{if(a)throw new Error("The service was stopped");let s=n++;let o=new SharedArrayBuffer(8);let u=new Int32Array(o);let f={sharedBuffer:o,id:s,command:r,args:i};l.postMessage(f);let c=Atomics.wait(u,0,0);if(c!=="ok"&&c!=="not-equal")throw new Error("Internal error: Atomics.wait() failed: "+c);let{message:{id:g,resolve:d,reject:p,properties:h}}=e.receiveMessageOnPort(t);if(s!==g)throw new Error(`Internal error: Expected id ${s} but got id ${g}`);if(p){applyProperties(p,h);throw p}return d};l.unref();return{buildSync(e){validateBuildSyncOptions(e);return runCallSync("build",[e])},transformSync(e,t){return runCallSync("transform",[e,t])},formatMessagesSync(e,t){return runCallSync("formatMessages",[e,t])},analyzeMetafileSync(e,t){return runCallSync("analyzeMetafile",[e,t])}}};var startSyncServiceWorker=()=>{let e=S.workerData.workerPort;let t=S.parentPort;let r=ensureServiceIsRunning();P=S.workerData.defaultWD;let extractProperties=e=>{let t={};if(e&&typeof e==="object"){for(let r in e){t[r]=e[r]}}return t};t.on("message",(t=>{(async()=>{let{sharedBuffer:l,id:n,command:a,args:i}=t;let s=new Int32Array(l);try{switch(a){case"build":e.postMessage({id:n,resolve:await r.build(i[0])});break;case"transform":e.postMessage({id:n,resolve:await r.transform(i[0],i[1])});break;case"formatMessages":e.postMessage({id:n,resolve:await r.formatMessages(i[0],i[1])});break;case"analyzeMetafile":e.postMessage({id:n,resolve:await r.analyzeMetafile(i[0],i[1])});break;default:throw new Error(`Invalid command: ${a}`)}}catch(t){e.postMessage({id:n,reject:t,properties:extractProperties(t)})}Atomics.add(s,0,1);Atomics.notify(s,0,Infinity)})()}))};if(O){startSyncServiceWorker()}var _=u;0&&0},471:function(e){e.exports=require("$LOCAL")},81:function(e){e.exports=require("child_process")},113:function(e){e.exports=require("crypto")},147:function(e){e.exports=require("fs")},37:function(e){e.exports=require("os")},17:function(e){e.exports=require("path")},125:function(e){e.exports=require("pnpapi")},224:function(e){e.exports=require("tty")},267:function(e){e.exports=require("worker_threads")}};var t={};function __nccwpck_require__(r){var l=t[r];if(l!==undefined){return l.exports}var n=t[r]={exports:{}};var a=true;try{e[r](n,n.exports,__nccwpck_require__);a=false}finally{if(a)delete t[r]}return n.exports}if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var r=__nccwpck_require__(364);module.exports=r})();